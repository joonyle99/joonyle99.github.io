---
layout: single
title:  "DirectX 3D 11 Tutorial 03 - Shader"
---

---

이전 튜토리얼에서 Vertex Buffer, Vertex Layout을 Vertex Shader에 연결했다.

```c++

	// Set the input layout
	g_pDeviceContext->IASetInputLayout(g_pVertexLayout);

	// Set vertex buffer
	g_pDeviceContext->IASetVertexBuffers(0, 1, &g_pVertexBuffer, &stride, &offset);

```

Shader에 대해 자세히 알아보자

Render()에서

```c++

	// Render a triangle
	g_pDeviceContext->VSSetShader(g_pVertexShader, nullptr, 0);
	g_pDeviceContext->PSSetShader(g_pPixelShader, nullptr, 0);
	g_pDeviceContext->Draw(3, 0);

```

해당 코드를 통해 Vertex Shader와 Pixel Shader를 Render Pipeline에 Binding했다.  

Shader는 Render Pipeline에서 GPU에서 짧게 실행되는 프로그램으로,  
입력 받은 데이터를 처리하고 그 결과가 다음 Pipeline의 입력으로 다시 들어가는 형태  
[Input Data 01 -> Ouput Data 01] -> [Input Data 02 -> Output Data 02] -> ...  

HLSL (High Level Shading Language) 언어를 사용한다.  
다음 Vertex Shader의 HLSL 코드는 입력받은 데이터를 그대로 출력한다

```c++

float4 VS( float4 Pos : POSITION ) : SV_POSITION
    {
        return Pos;
    }

```

float4 데이터를 매개변수로 입력받고, float4 그대로 반환한다.  
앞으로 다룰 Shader는 이 과정에서 **데이터의 처리**가 들어갈 것이다.  
SV_POSITION은 HLSL의 Semantic인데, **데이터의 특성**을 설명하며 사전 정의된다.

<br>

이번에는 Pixel Shader에 대해 알아보자.  
최신 컴퓨터 모니터는 Raster Display로, 화면에 Pixel로 이루어져 있다.  
각 Pixel들은 독립적인 색상을 가지고 있으며, 삼각형을 출력할때도 수많은 Pixel로 이루어진  
개체로 삼각형이 그려진다.

![image](https://gasbebe.github.io/images/fragmentAnim.gif){: .align-center}

