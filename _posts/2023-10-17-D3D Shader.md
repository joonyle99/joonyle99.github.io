---
layout: single
title:  "DirectX 3D 11 Tutorial 03 - Shader"
---

---

```c++

	// Set the input layout
	g_pDeviceContext->IASetInputLayout(g_pVertexLayout);

	// Set vertex buffer
	g_pDeviceContext->IASetVertexBuffers(0, 1, &g_pVertexBuffer, &stride, &offset);

```

이전 InitDevice() 단계에서 Vertex Buffer, Vertex Layout을 Vertex Shader에 연결했다.  

```c++

	// Render a triangle
	g_pDeviceContext->VSSetShader(g_pVertexShader, nullptr, 0);
	g_pDeviceContext->PSSetShader(g_pPixelShader, nullptr, 0);
	g_pDeviceContext->Draw(3, 0);

```

그리고 Vertex Shader와 Pixel Shader를 Render Pipeline에 Binding했다.  
Render Pipeline에서 중요한 역할을 하는 Shader에 대해 알아보자.  

---

Shader란 GPU에서 짧게 실행되는 프로그램으로, 입력된 데이터를 변환, 처리한다.  

```c++

float4 VS( float4 Pos : POSITION ) : SV_POSITION
    {
        return Pos;
    }

```

위의 코드는 HLSL로 작성된 **Vertex Shader** 코드인데, 입력받은 데이터를 그대로 출력하겠다는 내용이다.  

1. float4 자료형의 POSITION 데이터를 매개변수로 입력받는다.
2. float4 Pos를 그대로 반환한다.

SV_POSITION은 HLSL의 Semantic인데, **데이터의 특성**을 설명하며, 사전에 정의된다.  

---

이번에는 **Pixel Shader**에 대해 알아보자.  

최신 컴퓨터 모니터는 Raster Display로, 화면에 Pixel로 이루어져 있다.  
각 Pixel들은 독립적인 색상을 가지고 있으며, 삼각형 하나라도 수많은 Pixel로 이루어진다.  

![image](https://gasbebe.github.io/images/fragmentAnim.gif){: .align-center}

세 개의 꼭짓점으로 이루어진 삼각형을 픽셀의 집합으로 변환하는 과정을 Rasterization 이라고 하며, 다음 과정을 거친다.  

1. 세 개의 꼭짓점 내부의 픽셀을 결정한다.
2. 각 픽셀에 대해 Pixel Shader를 호출한다. (각 픽셀이 어떠한 색상을 가져야 하는지 계산하는 단계)
3. 색상이 결정된 픽셀을 다음 파이프라인으로 Output한다.

```c++

float4 PS( float4 Pos : SV_POSITION ) : SV_Target
    {
        return float4( 1.0f, 1.0f, 0.0f, 1.0f );    // Yellow, with Alpha = 1
    }

```

Vertex Shader에서 float4의 SV_POSITION을 입력받아온다.  
이후 Pixel Shader는 색상값을 출력하므로 float4를 반환한다.  
Pixel Shader의 Semantic은 SV_TARGET을 사용한다.
